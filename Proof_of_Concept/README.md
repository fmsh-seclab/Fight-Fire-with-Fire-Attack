# Proof of Concept

## File Descriptions
- **`decrypted_mb1/`**: Contains the decrypted rcm message and orignal MB1 files provide by Nvidia.

- **`em_trace/`**: Contains the EM trace-set we captured during the decryption of the MB1 firmware with SBK.

- **`rcm_message/`**: Contains the encrypted MB1 files generated by Jetson Linux BSP tool kit.  

- **`jetson_32bit_cpa.cu`**: Implements a GPU-accelerated 32bit CPA algorithm for key recovery (source code).
  
- **`Result.txt`**: Records CPA result, including: top 4 candidate key with correlation coefficients and the AES-128 master key.
  
- **`roundkey.bin`**: Stores round keys generated by the CPA algorithm in `jetson_32bit_cpa.cu`.

- **`decrypt.py`**: Python script to decrypt the rcm message with `SBK`.
- 
- **`POC.sh`**: Automates the POC workflow:
  - 1. Compiles `jetson_32bit_cpa.cu` into an executable `jetson_32bit_cpa`.
  - 2. Runs the CUDA program `jetson_32bit_cpa` and output `SBK` value to `Result.txt`.
  - 3. Runs the Python script `decrypt.py` to decrypt the encrypted MB1 files in `rcm_message/` with `SBK` and store to `decrypted_rcm_message/`.


## OS Requirements for PoC
- **`OS Requirements`**: Linux x86-64
- **`Docker Image`**: <nvcr.io/nvidia/cuda:12.1.1-devel-ubuntu22.04> 
- **`Python Version`**: ≥ 3.8
- **`GPU Requirements`**: 4 x Nvidia GPU (4 Nvidia L40S GPU or above)


## PoC Usage 
```bash
chmod +x POC.sh    # Grant execute permissions
./POC.sh           # Run the script
```
## Key Recovery Result
Run the `POC.sh` script and wait for the execution to complete (~10 hs). The program will crack the `SBK`, then use the key to decrypt the rcm message and store the result in the `decrypted_mb1` folder.
Key Recovery Results as follow:
  
  ```log
  ......................................................
  Compiling POC program with nvcc...
  POC executable created: jetson_32bit_cpa
  ......................................................
  Cracking SBK ... 
  Start Processing 120000 Traces, Please wait about 600 mins.
  AES-128 RoundKey Candidate Set 0 :
  Rank 0: 0x132BA717, Vlaue: 0.169757
  Rank 1: 0x979456BC, Vlaue: 0.143959
  Rank 2: 0x1E806ACC, Vlaue: 0.143207
  Rank 3: 0xAFF064BF, Vlaue: 0.143023
  AES-128 RoundKey Candidate Set 2 :
  Rank 0: 0xF3941DC5, Vlaue: 0.152342
  Rank 1: 0xB0F4AA9D, Vlaue: 0.145041
  Rank 2: 0xC8B09277, Vlaue: 0.144563
  Rank 3: 0x92B78128, Vlaue: 0.144265
  AES-128 RoundKey Candidate Set 3 :
  Rank 0: 0x4D074A7F, Vlaue: 0.180107
  Rank 1: 0x8B78183B, Vlaue: 0.147911
  Rank 2: 0x6682150B, Vlaue: 0.145847
  Rank 3: 0x7C613AA5, Vlaue: 0.144677
  AES-128 RoundKey Candidate Set 1 :
  Rank 0: 0xE311308B, Vlaue: 0.172797
  Rank 1: 0xEF1675EA, Vlaue: 0.144187
  Rank 2: 0xC157D24A, Vlaue: 0.143428
  Rank 3: 0x8F2F1542, Vlaue: 0.143308
  AES Cipher Key : 000102030405060708090A0B0C0D0E0F
  Completed.
  SBK crack successfully!
  ......................................................
  Starting decryption process...
  Decryption completed successfully!
  ......................................................
  ```
## Validation
Check whether the decrypted result  . Taking the MB1 firmware in `BSP version 32.4.2` as an example, some of its plaintext details are illustrated in the figure below.
## TRS File Format Specification
#### **1. Overview**
The **TRS file** (Trace Storage Format) is a structured binary format designed by **Riscure** for storing traces acquired during side-channel analysis. A TRS file consists of a *header* containing metadata followed by sequential *trace records* storing acquisition data.


#### **2. TRS File Structure**
The file is composed of two main sections:

```
┌──────────────┬───────────────────────────────────────────────────────────┐
│  TRS Header  │  Trace 1 │ Trace 2 │ ... │ Trace N  │  Optional Footer     │
└──────────────┴───────────────────────────────────────────────────────────┘
```

##### **2.1 Header Format**
The header contains mandatory and optional tag-value fields in the following structure:

| Tag (Hex) | Name      | Data Type   | Description                          | **Binary Example** | Example Value |
|-----------|-----------|-------------|--------------------------------------|:---------------|-----------|
| **0x41**  | NT        | uint32 (LE) | Number of traces in the file         | `41 04 08 00 00 00` | NT = `0x00000008` |
| **0x42**  | NS        | uint32 (LE) | Number of samples per trace          | `42 04 F0 7D 23 00` | NS = `0x00237DF0` |
| **0x43**  | SC        | uint8       | Sample coding:<br>• BIT5: `1`=float, `0`=int<br>• BIT0-1: Bytes per sample `(1 << n)` | `43 01 01` | SC = `0x01` (1 bytes) |
| **0x44**  | DS        | uint16 (LE) | Data block length (bytes per trace)  | `44 02 10 00` | DS = `0x0010` |
| **0x45**  | RS        | uint8       | Reserved title space size (bytes)    | `45 01 29` | RS = `0x29` |
| **0x5F00**    | TB        | N/A         | Marks the end of the header block    | /             | / |

*Notes*:

1. Tags **0x41**, **0x42**, and **0x43** are **mandatory**.
2. All multi-byte integers use **little-endian** encoding.

##### **2.2 Trace Record Structure**
Each trace record contains three components, structured as:

```
┌────────────────────────┬───────────────────────┬────────────────────────┐
│ Title Space (RS bytes) │ Data Block (DS bytes) │ Sample Block (NS×SC)   │
└────────────────────────┴───────────────────────┴────────────────────────┘
```

- **Title Space** (Size: Defined by **0x45** tag)
  Reserved for trace-specific metadata or labels. Empty space is filled with `0x20` padding.
  *Example*: `0x74726163652020...2020` decodes to "trace".

- **Data Block** (Size: Defined by **0x44** tag)
  Contains auxiliary data associated with the trace (e.g., cryptographic inputs/outputs).

- **Sample Block** (Size: **NS × Bytes per sample**)
  Raw sample data in the format specified by **0x43** (SC):
  - For `int32`: Signed 4-byte integer.
  - For `byte8`: Signed 1-byte integer.

#### **3. Validation Requirements**
| Check                 | Criteria                                                     |
| --------------------- | ------------------------------------------------------------ |
| File Size Consistency | `NT × (RS + DS + NS×BytesPerSample) + HeaderSize ≈ Actual File Size` |
| NS Threshold          | Values exceeding 200,000,000 trigger warnings (potential scope configuration errors). |

#### **4. Vendor Extensions**
Undocumented tags (e.g., `0x49`, `0x4A`) may indicate vendor-specific extensions. Validate against hardware documentation.

---
